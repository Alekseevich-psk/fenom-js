Запомни все ключевые моменты. Я тебе дам код ядра fenom.js это мой аналог шаблонизатора fenom php. Это полноразмерная версия, с подержкой include extends и прочее. Мне нужно сделать его асинхронным и заточить под работу с vite+vituum. Где vituum делает всю работу со статикой. Пиши весь код, не сокращая. Если не хватает файлов для анализа, попроси я дам. Не придумывай сам. Так же учитывай, что дальше мы будем создавать плагин для работы с vituum. Значит, надо добавить нужный экспорт в index.ts. И все должно быть асинхронно. import type { TemplateLoader } from './types/common'; import { parse } from './parser/parser'; import { compile } from './compiler/compiler'; import { tokenize } from './lexer/tokenize'; import { filters } from './filters/filters'; import { minifyHTML } from './compiler/functions'; export function FenomJs( template: string, context?: Record<string, any>, options?: { root?: string; loader?: TemplateLoader; minify?: boolean; } ): string { const { root, loader, minify } = options || { root: './src/' }; const defaultLoader = loader || (() => ''); try { const tokens = tokenize(template); const ast = parse(tokens); const compiled = compile(ast, defaultLoader); const html = compiled(context, filters); return minify ? minifyHTML(html) : html; } catch (err) { console.error('Template error:', err); return `<span style='color:red'>[Ошибка шаблона: ${(err as Error).message}]</span>`; } }import { defineConfig } from 'vite'; import { resolve } from 'path'; export default defineConfig({ build: { outDir: 'fenom-js', emptyOutDir: false, minify: "terser", lib: { entry: resolve(__dirname, './index.ts'), name: 'fenom-js', formats: ['es', 'cjs'], fileName: (format) => `index.${format === 'es' ? 'mjs' : 'cjs'}`, }, }, resolve: { alias: { '@': resolve(__dirname, 'src'), }, } });import type { Token } from './../types/token'; import type { ASTNode } from './../types/common'; import { parseIf } from './parse-if'; import { parseFor } from './parse-for'; import { parseSwitch } from './parse-switch'; // parser/parser.ts export function parse(tokens: Token[]): ASTNode[] { const ast: ASTNode[] = []; let i = 0; while (i < tokens.length) { const token = tokens[i]; // --- Обработка block --- if (token.type === 'block_open') { const blockName = token.name; i++; // пропускаем {block ...} const blockTokens: Token[] = []; let depth = 0; while (i < tokens.length) { const current = tokens[i]; if (current.type === 'block_open') { depth++; } if (current.type === 'block_close') { if (depth === 0) break; depth--; } blockTokens.push(current); i++; } const body = parse(blockTokens); // ← рекурсивно парсим содержимое ast.push({ type: 'block', name: blockName, body, }); i++; // пропускаем {/block} continue; } // --- Обработка extends --- if (token.type === 'extends') { ast.push({ ...token }); i++; continue; } // --- Обработка include --- if (token.type === 'include') { ast.push({ ...token }); i++; continue; } // --- Остальные теги --- if (['set', 'var', 'add'].includes(token.type)) { ast.push({ ...token }); i++; continue; } if (token.type === 'if') { const { node, nextIndex } = parseIf(tokens, i); ast.push(node); i = nextIndex; continue; } if (token.type === 'for' || token.type === 'foreach') { const { node, nextIndex } = parseFor(tokens, i); ast.push(node); i = nextIndex; continue; } if (token.type === 'switch') { const { node, nextIndex } = parseSwitch(tokens, i); ast.push(node); i = nextIndex; continue; } if (token.type === 'output') { const match = token.value.match(/^\{\$(.+)\}$/); if (!match) { ast.push({ type: 'text', value: token.value }); i++; continue; } const content = match[1].trim(); const parts = content.split('|'); const variable = parts[0]; const filters = parts.slice(1); ast.push({ type: 'output', name: `$${variable}`, filters }); i++; continue; } // Простые токены ast.push({ ...token }); i++; } return ast; } import type { TemplateLoader } from './../types/common'; import { join } from 'path'; import { readFileSync } from 'fs'; export function createSyncLoader(root: string): TemplateLoader { return function loader(file: string) { const fullPath = join(root, file); if (!fullPath.endsWith('.tpl')) { throw new Error(`Template path must end with .tpl: ${file}`); } if (!readFileSync(fullPath, 'utf-8')) { throw new Error(`Template not found: ${fullPath}`); } return readFileSync(fullPath, 'utf-8'); }; }import type { TokenPattern, Token } from './../types/token'; import * as Patterns from './patterns'; // Объединяем все паттерны const ALL_PATTERNS: TokenPattern[] = [ ...Patterns.EXTENDS_PATTERNS, ...Patterns.INCLUDE_PATTERNS, ...Patterns.FOREACH_PATTERNS, ...Patterns.SWITCH_PATTERNS, ...Patterns.OPERATOR_PATTERN, ...Patterns.IF_PATTERNS, ...Patterns.IGNORE_PATTERN, ...Patterns.SET_PATTERNS, ...Patterns.MISC_PATTERNS, ...Patterns.OUTPUT_PATTERN, ...Patterns.CYCLE_PATTERNS, ...Patterns.FILTER_PATTERNS, ...Patterns.MACRO_PATTERNS, ]; export function tokenize(input: string): Token[] { const tokens: Token[] = []; let pos = 0; while (pos < input.length) { let matched = false; if (input.slice(pos).startsWith('{ignore}')) { let depth = 1; let i = pos + 8; // длина '{ignore}' while (i < input.length) { if (input.slice(i).startsWith('{ignore}')) { depth++; i += 8; } else if (input.slice(i).startsWith('{/ignore}')) { depth--; i += 9; if (depth === 0) { // Нашли конец const content = input.slice(pos + 8, i - 9); // только содержимое tokens.push({ type: 'text', value: content }); pos = i; // ставим после {/ignore} matched = true; break; } } else { i++; } } // Если не нашли закрывающий тег if (!matched) { tokens.push({ type: 'text', value: '{ignore}' }); pos += 8; } continue; } if (input[pos] !== '{') { const next = input.indexOf('{', pos); if (next === -1) { tokens.push({ type: 'text', value: input.slice(pos) }); break; } else { if (next > pos) { tokens.push({ type: 'text', value: input.slice(pos, next) }); } pos = next; } } for (const pattern of ALL_PATTERNS) { const substr = input.slice(pos); const match = substr.match(pattern.regex); if (match) { const token: Token = { type: pattern.type, value: match[0] // ← добавляем оригинальный текст токена }; if (pattern.type === 'comment') { // Пропускаем: не добавляем в tokens pos += match[0].length; matched = true; break; } if (pattern.process) { Object.assign(token, pattern.process(match)); } tokens.push(token); pos += match[0].length; matched = true; break; } } if (!matched) { const context = input.slice(pos, pos + 30).replace(/\n/g, '↵'); console.warn(`Skip unknown tag at ${pos}: "${context}"`); pos++; } } return tokens; } import { warnFilter } from './../compiler/functions'; export const filters = { // ——— Строковые фильтры ———————————————————————— /** * Преобразует строку в верхний регистр */ upper: (s: any) => String(s).toUpperCase(), /** * Преобразует строку в нижний регистр */ lower: (s: any) => String(s).toLowerCase(), /** * Делает первую букву строки заглавной, остальные — строчными * 'аННА' → 'Анна' */ capitalize: (s: any) => { const str = String(s).trim(); if (str.length === 0) return ''; return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase(); }, /** * Аналог capitalize (для совместимости) */ ucfirst: (s: any) => filters.capitalize(s), /** * Делает первую букву каждого слова заглавной * 'hello world' → 'Hello World' */ ucwords: (s: any) => { const str = String(s).trim(); return str.replace(/\b\w/g, (match) => match.toUpperCase()); }, /** * Делает первую букву строки строчной * 'Hello' → 'hello' */ lcfirst: (s: any) => { const str = String(s).trim(); if (str.length === 0) return ''; return str.charAt(0).toLowerCase() + str.slice(1); }, /** * Удаляет пробелы с краёв строки */ trim: (s: any) => String(s).trim(), /** * Удаляет пробелы слева */ ltrim: (s: any) => String(s).replace(/^\s+/, ''), /** * Удаляет пробелы справа */ rtrim: (s: any) => String(s).replace(/\s+$/, ''), /** * Преобразует \n → <br> */ nl2br: (s: any) => String(s).replace(/\n/g, '<br>'), /** * Заменяет подстроку * {$str|replace:'old':'new'} */ replace: (s: any, search: string, replace: string) => { const str = String(s); return str.split(String(search)).join(String(replace)); }, /** * Обрезает строку * {$str|substr:0:5} */ substr: warnFilter('substr', 'string', (s: any, start: number, length?: number) => { const str = String(s); return length === undefined ? str.slice(start) : str.slice(start, start + length); }), /** * Кодирует строку в URL */ urlencode: (s: any) => encodeURIComponent(String(s)), /** * Декодирует URL */ urldecode: (s: any) => decodeURIComponent(String(s)), /** * Экранирует HTML-символы */ escape: warnFilter('escape', 'string', (s: any) => { const str = String(s); return str .replace(/&/g, '&amp;') .replace(/</g, '&lt;') .replace(/>/g, '&gt;') .replace(/"/g, '&quot;') .replace(/'/g, '&#039;'); }), /** * Синоним escape */ e: (s: any) => filters.escape(s), // ——— Работа с массивами —————————————————————— /** * Первый элемент массива/объекта */ first: warnFilter('first', 'array', (arr: any) => { if (Array.isArray(arr)) return arr[0]; if (arr && typeof arr === 'object') return Object.values(arr)[0]; return ''; }), /** * Последний элемент массива/объекта */ last: warnFilter('last', 'array', (arr: any) => { if (Array.isArray(arr)) return arr[arr.length - 1]; if (arr && typeof arr === 'object') { const values = Object.values(arr); return values[values.length - 1]; } return ''; }), /** * Объединяет массив в строку * {$arr|join:', '} */ join: warnFilter('join', 'array', (arr: any, separator: string = ',') => { if (Array.isArray(arr)) return arr.join(separator); if (arr && typeof arr === 'object') return Object.values(arr).join(separator); return String(arr); }), /** * Переворачивает массив или строку */ reverse: warnFilter('reverse', 'array', (arr: any) => { if (Array.isArray(arr)) return [...arr].reverse(); if (typeof arr === 'string') return arr.split('').reverse().join(''); return arr; }), /** * Сортирует массив по значениям */ sort: warnFilter('sort', 'array', (arr: any) => { if (Array.isArray(arr)) return [...arr].sort(); return arr; }), /** * Сортирует массив по ключам */ ksort: warnFilter('ksort', 'object', (obj: any) => { if (obj && typeof obj === 'object') { const sorted: any = {}; Object.keys(obj).sort().forEach(key => { sorted[key] = obj[key]; }); return sorted; } return obj; }), /** * Возвращает только уникальные значения */ unique: warnFilter('unique', 'array', (arr: any) => { if (Array.isArray(arr)) return [...new Set(arr)]; return arr; }), /** * Перемешивает массив */ shuffle: warnFilter('shuffle', 'array', (arr: any) => { if (!Array.isArray(arr)) return arr; const newArr = [...arr]; for (let i = newArr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [newArr[i], newArr[j]] = [newArr[j], newArr[i]]; } return newArr; }), /** * Возвращает срез массива/строки * {$arr|slice:0:2} */ slice: (arr: any, start: number, length?: number) => { if (Array.isArray(arr) || typeof arr === 'string') { return length === undefined ? arr.slice(start) : arr.slice(start, start + length); } return arr; }, /** * Объединяет два массива * {$arr1|merge:$arr2} */ merge: (arr1: any, arr2: any) => { if (Array.isArray(arr1) && Array.isArray(arr2)) { return [...arr1, ...arr2]; } return arr1; }, /** * Разбивает массив на группы * {$items|batch:3} */ batch: (arr: any, size: number) => { if (!Array.isArray(arr)) return arr; const result = []; for (let i = 0; i < arr.length; i += size) { result.push(arr.slice(i, i + size)); } return result; }, /** * Возвращает ключи массива/объекта */ keys: (obj: any) => (obj && typeof obj === 'object' ? Object.keys(obj) : []), /** * Возвращает значения массива/объекта */ values: (obj: any) => (obj && typeof obj === 'object' ? Object.values(obj) : []), /** * Длина строки или количество элементов */ length: (arr: any) => { if (Array.isArray(arr)) return arr.length; if (arr && typeof arr === 'object') return Object.keys(arr).length; return String(arr).length; }, // ——— Форматирование и числа —————————————————— /** * Форматирует число * {$price|number_format:2:'.':','} */ number_format: (num: any, decimals: number = 0, decPoint: string = '.', thousandsSep: string = ',') => { const n = Number(num); if (isNaN(n)) return ''; return n.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals, useGrouping: true }).replace(/,/g, thousandsSep).replace(/\./g, decPoint); }, /** * Абсолютное значение */ abs: (n: any) => Math.abs(Number(n) || 0), /** * Округляет число */ round: (n: any, precision: number = 0) => { const factor = 10 ** precision; return Math.round((Number(n) || 0) * factor) / factor; }, // ——— JSON ———————————————————————————————— /** * Кодирует в JSON */ json_encode: (data: any) => JSON.stringify(data), /** * Декодирует из JSON */ json_decode: (str: any) => { try { return JSON.parse(String(str)); } catch { return null; } }, // ——— Дата ———————————————————————————————— /** * Форматирует timestamp * Формат: d.m.Y H:i:s */ date: (timestamp: any, format: string = 'd.m.Y') => { const n = Number(timestamp); const d = new Date(isNaN(n) ? timestamp : n * 1000); if (isNaN(d.getTime())) { console.warn(`[Fenom] filter 'date' received invalid timestamp: ${timestamp}`); return ''; } const pad = (n: number) => n.toString().padStart(2, '0'); return format .replace(/d/g, pad(d.getDate())) .replace(/m/g, pad(d.getMonth() + 1)) .replace(/Y/g, d.getFullYear().toString()) .replace(/H/g, pad(d.getHours())) .replace(/i/g, pad(d.getMinutes())) .replace(/s/g, pad(d.getSeconds())); }, // ——— Прочее —————————————————————————————— /** * Возвращает значение по умолчанию, если пусто */ default: (s: any, def: string) => { return (s == null || s === '' || (typeof s === 'object' && Object.keys(s).length === 0)) ? def : s; }, /** * Вывод без изменений */ raw: (s: any) => s, /** * Отладка: вывод структуры */ var_dump: (data: any) => { return `<pre>${JSON.stringify(data, null, 2)}</pre>`; }, /** * Отладка: красивый вывод */ print_r: (data: any) => { return `<pre>${data instanceof Object ? JSON.stringify(data, null, 2) : String(data)}</pre>`; } }; import type { ASTNode, TemplateLoader } from './../types/common'; import { contextPath, parseValue, transformExpression } from './functions'; import { tokenize } from '../lexer/tokenize'; import { parse } from '../parser/parser'; import { transformCondition } from './../compiler/functions'; export function compile(ast: ASTNode[], loader: TemplateLoader): (context: any, filters: any) => string { const blocks: Record<string, ASTNode[]> = {}; let parentFile: string | null = null; const lines: string[] = []; // Извлекаем extends и блоки for (const node of ast) { if (node.type === 'extends') { parentFile = node.file; // например, "layouts/base.tpl" continue; } if (node.type === 'block') { blocks[node.name] = node.body; } } const filteredAst = ast.filter( node => node.type !== 'extends' && node.type !== 'block_open' && node.type !== 'block_close' ); function compileNode(node: ASTNode) { if (['extends', 'block_open', 'block_close'].includes(node.type)) { return; // обрабатываются отдельно } if (['endfor'].includes(node.type)) { return; // игнорирую } switch (node.type) { case 'operator': { const { variable, operator, value } = node; // Преобразуем значение: если начинается с $ → context.var const getValue = (val: string) => { if (val.startsWith('$')) { return `context.${val.slice(1)}`; } return isNaN(+val) ? `'${val}'` : +val; // число или строка }; switch (operator) { case '++': lines.push(`context.${variable} = (context.${variable} || 0) + 1;`); lines.push(`out += context.${variable} - 1;`); // пост-инкремент break; case '--': lines.push(`context.${variable} = (context.${variable} || 0) - 1;`); lines.push(`out += context.${variable} + 1;`); // пост-декремент break; case '+=': lines.push(`context.${variable} = (context.${variable} || 0) + ${getValue(value)};`); lines.push(`out += context.${variable};`); break; case '-=': lines.push(`context.${variable} = (context.${variable} || 0) - ${getValue(value)};`); lines.push(`out += context.${variable};`); break; case '*=': lines.push(`context.${variable} = (context.${variable} || 0) * ${getValue(value)};`); lines.push(`out += context.${variable};`); break; case '/=': lines.push(`context.${variable} = (context.${variable} || 0) / ${getValue(value)};`); lines.push(`out += context.${variable};`); break; case '%=': lines.push(`context.${variable} = (context.${variable} || 0) % ${getValue(value)};`); lines.push(`out += context.${variable};`); break; } break; } case 'ignore_block': // Выводим содержимое как обычный текст lines.push(`out += ${JSON.stringify(node.content)};`); break; case 'include': { try { const includedTemplate = loader(node.file); const tokens = tokenize(includedTemplate); const ast = parse(tokens); if (node.params) { for (const [key, value] of Object.entries(node.params)) { // Проверяем, что value — строка if (typeof value === 'string') { if (value.startsWith('$')) { const varName = value.slice(1); lines.push(`context.${key} = context.${varName};`); } else { lines.push(`context.${key} = ${JSON.stringify(value)};`); } } else { // Если не строка — преобразуем в JSON (например, число, boolean) lines.push(`context.${key} = ${JSON.stringify(value)};`); } } } ast.forEach(compileNode); } catch (err) { lines.push(`out += '[Include error: ${node.file}]';`); } break; } case 'text': lines.push(`out += ${JSON.stringify(node.value)};`); break; case 'output': { const value = transformExpression(node.name); let result = value; // Применяем фильтры for (const filter of node.filters) { const parts = filter.split(':').map(s => s.trim()); const name = parts[0]; const args = parts.slice(1).map((arg: string) => { // ← добавлен :string if (/^['"].*['"]$/.test(arg)) { return arg; // строка в кавычках — оставляем как есть } const normalizedArg = arg.startsWith('$') ? arg : '$' + arg; return transformExpression(normalizedArg); }); const argList = args.length > 0 ? ', ' + args.join(', ') : ''; result = `filters["${name}"](${result}${argList})`; } if (node.filters.length === 0) { const safeValue = `(typeof ${value} === 'object' || ${value} === null ? '' : ${value})`; lines.push(`out += ${safeValue};`); } else { lines.push(`out += ${result};`); } break; } case 'set': // {set $name = 'Анна'} → context.name = 'Анна'; lines.push(`context.${node.variable} = ${parseValue(node.value)};`); break; case 'var': // {var $title = 'Главная'} → if (context.title === undefined) context.title = 'Главная'; lines.push(`if (context.${node.variable} === undefined) context.${node.variable} = ${parseValue(node.value)};`); break; case 'add': // {add $counter++} → context.counter = (context.counter || 0) + 1; lines.push(`context.${node.variable} = (context.${node.variable} || 0) + 1;`); break; case 'if': { const condition = transformCondition(node.condition); lines.push(`if (${condition}) {`); node.body.forEach(compileNode); lines.push('}'); // else if node.elseIfs.forEach(elseIf => { const cond = transformCondition(elseIf.condition); lines.push(`else if (${cond}) {`); elseIf.body.forEach(compileNode); lines.push('}'); }); if (node.elseBody.length > 0) { lines.push('else {'); node.elseBody.forEach(compileNode); lines.push('}'); } break; } case 'for': { const collection = transformExpression(node.collection); // → context.arr const itemVar = `context.${node.item}`; // → context.value const keyVar = node.key ? `context.${node.key}` : null; const indexVar = `i_${node.item}`; // Проверка: массив существует и не пуст lines.push(`if (${collection} && Array.isArray(${collection}) && ${collection}.length > 0) {`); // Цикл if (node.reverse) { lines.push(`for (let ${indexVar} = ${collection}.length - 1; ${indexVar} >= 0; ${indexVar}--) {`); } else { lines.push(`for (let ${indexVar} = 0; ${indexVar} < ${collection}.length; ${indexVar}++) {`); } // Присваиваем индекс (если есть key) if (keyVar) { lines.push(`${keyVar} = ${indexVar};`); } // Присваиваем элемент: context.value = context.arr[i] lines.push(`${itemVar} = ${collection}[${indexVar}];`); // Компилируем тело node.body.forEach(compileNode); // Закрываем цикл lines.push(`}`); lines.push(`}`); // {foreachelse} if (node.elseBody && node.elseBody.length > 0) { lines.push(`else {`); node.elseBody.forEach(compileNode); lines.push(`}`); } break; } case 'switch': lines.push(`switch (${contextPath(node.value)}) {`); node.cases.forEach((c: any) => { lines.push(`case ${c.value}: {`); c.body.forEach(compileNode); lines.push(`break; }`); }); if (node.defaultBody && node.defaultBody.length > 0) { lines.push(`default: {`); node.defaultBody.forEach(compileNode); lines.push(`break; }`); } lines.push(`}`); break; case 'block': { const blockContent = blocks[node.name] || node.body; if (Array.isArray(blockContent)) { blockContent.forEach(compileNode); } else { console.warn(`Block "${node.name}" has no body and no override`); } break; } default: console.warn(`Unknown node type: ${node.type}`); } } if (parentFile && ast.some((node, i) => node.type === 'extends' && i !== 0)) { console.warn('{extends} должен быть первым тегом в шаблоне'); } if (parentFile) { const parentTemplate = loader(parentFile); const tokens = tokenize(parentTemplate); const parentAst = parse(tokens); parentAst.forEach(compileNode); // ← родительский шаблон } else { filteredAst.forEach(compileNode); // ← текущий шаблон } const fnBody = ` let out = ''; ${lines.join('\n')} return out; `; return new Function('context', 'filters', fnBody) as (context: any, filters: any) => string; }import type { ASTNode } from './../types/common'; import { contextPath, parseValue, transformExpression } from './functions'; export function compileNode(node: ASTNode, lines: string[]): void { switch (node.type) { case 'text': lines.push(`out += ${JSON.stringify(node.value)};`); break; case 'output': const value = transformExpression(node.name); let result = `(${value})`; node.filters.forEach((filter: string) => { const [name, ...args] = filter.split(':').map(s => s.trim()); if (args.length === 0) { result = `filters.${name}(${result})`; } else { const argList = args.map(arg => { if (/^['"].*['"]$/.test(arg)) return arg; return transformExpression('$' + arg); }).join(', '); result = `filters.${name}(${result}, ${argList})`; } }); lines.push(`out += ${result} ?? '';`); break; case 'set': lines.push(`context.${node.variable} = ${parseValue(node.value)};`); break; case 'var': lines.push(`if (context.${node.variable} === undefined) context.${node.variable} = ${parseValue(node.value)};`); break; case 'add': lines.push(`context.${node.variable} = (context.${node.variable} || 0) + 1;`); break; case 'if': lines.push(`if (${contextPath(node.condition)}) {`); node.body.forEach(n => compileNode(n, lines)); if (node.elseIfs?.length) { node.elseIfs.forEach((elseIf: any) => { lines.push(`} else if (${contextPath(elseIf.condition)}) {`); elseIf.body.forEach((n: any) => compileNode(n, lines)); }); } if (node.elseBody?.length) { lines.push(`} else {`); node.elseBody.forEach(n => compileNode(n, lines)); lines.push(`}`); } lines.push(`}`); break; case 'for': { const key = node.key ? `context.${node.key} = ` : ''; const item = `context.${node.item}`; const collection = contextPath(node.collection); const indexVar = `i_${node.item}`; lines.push(`if (${collection} && Array.isArray(${collection}) && ${collection}.length > 0) {`); if (node.reverse) { lines.push(`for (let ${indexVar} = ${collection}.length - 1; ${indexVar} >= 0; ${indexVar}--) {`); } else { lines.push(`for (let ${indexVar} = 0; ${indexVar} < ${collection}.length; ${indexVar}++) {`); } if (key) lines.push(`${key} ${indexVar};`); lines.push(`${item} = ${collection}[${indexVar}];`); node.body.forEach(n => compileNode(n, lines)); lines.push(`}`); lines.push(`}`); if (node.elseBody?.length) { lines.push(`else {`); node.elseBody.forEach(n => compileNode(n, lines)); lines.push(`}`); } break; } case 'switch': lines.push(`switch (${contextPath(node.value)}) {`); node.cases.forEach((c: any) => { lines.push(`case ${c.value}: {`); c.body.forEach((n: any) => compileNode(n, lines)); lines.push(`break; }`); }); if (node.defaultBody?.length) { lines.push(`default: {`); node.defaultBody.forEach(n => compileNode(n, lines)); lines.push(`break; }`); } lines.push(`}`); break; case 'extends': break; case 'block': if (node.body && node.body.length > 0) { // Это определение — не рендерим return; } // Это вставка: {block "main"} lines.push(`out += await context.block('${node.name}');`); break; default: if (node.type !== 'extends' && node.type !== 'block') { console.warn(`Unknown node type: ${node.type}`); } } }